import React
import PayUCustomBrowser

@objc(CBWrapper)
class CBWrapper: RCTEventEmitter {
    
    // MARK: - Variables -
    
    private var hasListener: Bool = false
    private var webVC: PUCBWebVC?
    
    // MARK: - Override RCTEventEmitter Methods -
    
    override func startObserving() {
        hasListener = true
    }
    
    override func stopObserving() {
        hasListener = false
    }
    
    override func supportedEvents() -> [String]! {
        [PUCBConstants.cbListener]
    }
    
    override class func requiresMainQueueSetup() -> Bool {
        true
    }
    
    // MARK: - Deinit -
    
    deinit {
        resetCBDelegate()
    }
    
    // MARK: - Private functions -
    
    private func sendEventToReact(body: Any) {
        if hasListener {
            sendEvent(withName: PUCBConstants.cbListener, body: body)
        }
    }
    
    private func resetCBDelegate() {
        webVC?.cbWebVCDelegate = nil
    }
    
    // MARK: - Public Methods -
    
    @objc(openCB:errorCallback:successCallback:)
    func openCB(payuPaymentParams: NSDictionary,
                errorCallback: @escaping RCTResponseSenderBlock,
                successCallback: @escaping RCTResponseSenderBlock) -> Void {
        DispatchQueue.main.async { [weak self] in
            // Validate Params
            guard let self = self,
                  let payuPaymentParam = payuPaymentParams[PUCBConstants.payUPaymentParams] as? [AnyHashable : Any]
            else {
                errorCallback([PUCBConstants.invalidPaymentParams])
                return
            }
            // Open CB
            do {
                self.webVC = try PUCBWebVC(json: payuPaymentParam)
                guard let webVC = self.webVC
                else {
                    errorCallback([PUCBConstants.somethingWentWrong])
                    return
                }
                // Delegate
                webVC.cbWebVCDelegate = self;
                // Present on Root VC
                let rootVc = RCTPresentedViewController()
                if rootVc?.navigationController != nil {
                    rootVc?.navigationController?.isNavigationBarHidden = false
                    rootVc?.navigationController?.pushViewController(webVC, animated: true)
                } else {
                    webVC.modalPresentationStyle = .fullScreen
                    rootVc?.present(webVC, animated: true)
                }
                // Success callback
                successCallback([PUCBConstants.paymentInitiated])
            } catch {
                errorCallback([error.localizedDescription])
            }
        }
    }
    
}

// MARK: - PUCBWebVCDelegate Methods -

extension CBWrapper: PUCBWebVCDelegate {
    
    func payUSuccessResponse(_ response: Any!) {
        // No need to handle
    }
    
    func payUFailureResponse(_ response: Any!) {
        // No need to handle
    }
    
    func payUSuccessResponse(_ payUResponse: Any!, surlResponse: Any!) {
        let body: [String: Any?] = [
            PUCBConstants.eventType: PUCBConstants.paymentSuccess,
            PUCBConstants.payuResult: payUResponse,
            PUCBConstants.merchantResponse: surlResponse,
        ]
        sendEventToReact(body: body as Any)
        resetCBDelegate()
    }
    
    func payUFailureResponse(_ payUResponse: Any!, furlResponse: Any!) {
        let body: [String: Any?] = [
            PUCBConstants.eventType: PUCBConstants.paymentFailure,
            PUCBConstants.payuResult: payUResponse,
            PUCBConstants.merchantResponse: furlResponse,
        ]
        sendEventToReact(body: body as Any)
        resetCBDelegate()
    }
    
    func payUConnectionError(_ notification: [AnyHashable : Any]!) {
        let body: [String: Any?] = [
            PUCBConstants.eventType: PUCBConstants.onErrorReceived,
            PUCBConstants.errorCode: PUCBConstants.networkErrorCode,
            PUCBConstants.errorMessage: PUCBConstants.networkErrorMessage,
        ]
        sendEventToReact(body: body as Any)
        resetCBDelegate()
    }
    
    func payUTransactionCancel() {
        let body = [
            PUCBConstants.eventType: PUCBConstants.paymentTerminate,
        ]
        sendEventToReact(body: body as Any)
        resetCBDelegate()
    }
    
}
